{
  "queries": [
    {
      "name": "Exact Match Query",
      "function": "exact_match_query",
      "code_to_execute": "SELECT * FROM '{parquet_file}' WHERE {column_name} = '{value}' AND lat = {lat} AND lon = {lon};",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "column_name": "Name of the column to match against",
        "value": "The exact value to search",
        "lat": "Optional latitude value",
        "lon": "Optional longitude value"
      },
      "output_expected": "A dataset containing all rows where the column exactly matches the provided value and coordinates if specified.",
      "explanation": "This query filters the dataset by verifying each row's specified column against an exact value and optional coordinates.",
      "details": "Use this query when you need to retrieve data based on an exact match with optional coordinate filtering.",
      "function_call": "exact_match_query(parquet_file='{parquet_file}', column_name='{column_name}', value='{value}', lat={lat}, lon={lon})",
      "imports_required": ["import duckdb"]
    },
    {
      "name": "LIKE Query",
      "function": "like_query",
      "code_to_execute": "SELECT * FROM '{parquet_file}' WHERE {column_name} LIKE '{pattern}' AND lat = {lat} AND lon = {lon};",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "column_name": "Column name to perform pattern matching",
        "pattern": "The pattern to search for, e.g., 'prefix%'",
        "lat": "Optional latitude value",
        "lon": "Optional longitude value"
      },
      "output_expected": "Rows where the column contains values matching the specified pattern and coordinates if specified.",
      "explanation": "Uses the SQL LIKE operator to facilitate pattern matching on text data with optional coordinate filtering.",
      "details": "Useful for fuzzy matching with optional location filtering.",
      "function_call": "like_query(parquet_file='{parquet_file}', column_name='{column_name}', pattern='{pattern}', lat={lat}, lon={lon})",
      "imports_required": ["import duckdb"]
    },
    {
      "name": "At Coordinates Query",
      "function": "at_coordinates_query",
      "code_to_execute": "SELECT *, SQRT(POWER(lat - {target_lat}, 2) + POWER(lon - {target_lon}, 2)) as distance FROM '{parquet_file}' WHERE {column_name} = '{value}' AND lat = {target_lat} AND lon = {target_lon};",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "column_name": "Name of the column to filter",
        "value": "Value to match in the column",
        "target_lat": "Target latitude value",
        "target_lon": "Target longitude value"
      },
      "output_expected": "Records that exactly match the given coordinates and column value, with distance calculation.",
      "explanation": "This query retrieves data that is precisely at the specified coordinates with matching column value.",
      "details": "Useful for pinpointing exact locations with specific attributes.",
      "function_call": "at_coordinates_query(parquet_file='{parquet_file}', column_name='{column_name}', value='{value}', target_lat={target_lat}, target_lon={target_lon})",
      "imports_required": ["import duckdb"]
    },
    {
      "name": "Within Radius Query",
      "function": "within_radius_query",
      "code_to_execute": "SELECT *, 6371 * 2 * ASIN(SQRT(POWER(SIN(RADIANS({target_lat} - lat) / 2), 2) + COS(RADIANS(lat)) * COS(RADIANS({target_lat})) * POWER(SIN(RADIANS({target_lon} - lon) / 2), 2))) as distance_km FROM '{parquet_file}' WHERE {column_name} = '{value}' HAVING distance_km <= {radius} ORDER BY distance_km ASC;",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "column_name": "Name of the column to filter",
        "value": "Value to match in the column",
        "target_lat": "Target latitude value",
        "target_lon": "Target longitude value",
        "radius": "Radius in kilometers within which to search"
      },
      "output_expected": "Records within the specified radius that match the column value, ordered by distance.",
      "explanation": "Finds records within a given radius using the Haversine formula for distance calculation.",
      "details": "Distance is calculated in kilometers. Results are ordered from nearest to farthest.",
      "function_call": "within_radius_query(parquet_file='{parquet_file}', column_name='{column_name}', value='{value}', target_lat={target_lat}, target_lon={target_lon}, radius={radius})",
      "imports_required": ["import duckdb"]
    },
    {
      "name": "Nearest Query",
      "function": "nearest_query",
      "code_to_execute": "SELECT *, 6371 * 2 * ASIN(SQRT(POWER(SIN(RADIANS({target_lat} - lat) / 2), 2) + COS(RADIANS(lat)) * COS(RADIANS({target_lat})) * POWER(SIN(RADIANS({target_lon} - lon) / 2), 2))) as distance_km FROM '{parquet_file}' WHERE {column_name} = '{value}' ORDER BY distance_km ASC LIMIT {limit};",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "column_name": "Name of the column to filter",
        "value": "Value to match in the column",
        "target_lat": "Target latitude value",
        "target_lon": "Target longitude value",
        "limit": "Number of nearest records to return (default: 5)"
      },
      "output_expected": "The nearest records to the specified coordinates that match the column value.",
      "explanation": "Finds the closest records to given coordinates, ordered by distance.",
      "details": "Uses Haversine formula for distance calculation in kilometers.",
      "function_call": "nearest_query(parquet_file='{parquet_file}', column_name='{column_name}', value='{value}', target_lat={target_lat}, target_lon={target_lon}, limit={limit})",
      "imports_required": ["import duckdb"]
    },
    {
      "name": "Count Within Radius Query",
      "function": "count_within_radius_query",
      "code_to_execute": "WITH distances AS (SELECT *, 6371 * 2 * ASIN(SQRT(POWER(SIN(RADIANS({target_lat} - lat) / 2), 2) + COS(RADIANS(lat)) * COS(RADIANS({target_lat})) * POWER(SIN(RADIANS({target_lon} - lon) / 2), 2))) as distance_km FROM '{parquet_file}' WHERE {column_name} = '{value}') SELECT COUNT(*) as count, MIN(distance_km) as min_distance_km, MAX(distance_km) as max_distance_km FROM distances WHERE distance_km <= {radius};",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "column_name": "Name of the column to filter",
        "value": "Value to match in the column",
        "target_lat": "Target latitude value",
        "target_lon": "Target longitude value",
        "radius": "Radius in kilometers within which to count"
      },
      "output_expected": "Count of records within radius with min and max distances.",
      "explanation": "Counts records within specified radius and provides distance statistics.",
      "details": "Uses Haversine formula for accurate distance calculation in kilometers.",
      "function_call": "count_within_radius_query(parquet_file='{parquet_file}', column_name='{column_name}', value='{value}', target_lat={target_lat}, target_lon={target_lon}, radius={radius})",
      "imports_required": ["import duckdb"]
    },
    {
      "name": "Bounding Box Query",
      "function": "bounding_box_query",
      "code_to_execute": "SELECT * FROM '{parquet_file}' WHERE {lat_col} BETWEEN {min_lat} AND {max_lat} AND {lon_col} BETWEEN {min_lon} AND {max_lon};",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "lat_col": "Name of the latitude column",
        "lon_col": "Name of the longitude column",
        "min_lat": "Minimum latitude value",
        "max_lat": "Maximum latitude value",
        "min_lon": "Minimum longitude value",
        "max_lon": "Maximum longitude value"
      },
      "output_expected": "All records that fall within the defined rectangular area.",
      "explanation": "Filters records whose latitude and longitude lie within the specified ranges.",
      "details": "Useful for spatial queries that define areas with bounding coordinates.",
      "function_call": "bounding_box_query(parquet_file='{parquet_file}', lat_col='{lat_col}', lon_col='{lon_col}', min_lat={min_lat}, max_lat={max_lat}, min_lon={min_lon}, max_lon={max_lon})",
      "imports_required": ["import duckdb"]
    },
    {
      "name": "Aggregate Query",
      "function": "aggregate_query",
      "code_to_execute": "SELECT {group_column}, COUNT(*) FROM '{parquet_file}' WHERE ST_Distance(ST_Point({lon_col}, {lat_col}), ST_Point({target_lon}, {target_lat})) < {radius} GROUP BY {group_column};",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "group_column": "Column name to group the results by",
        "lat_col": "Name of the latitude column",
        "lon_col": "Name of the longitude column",
        "target_lat": "Target latitude value",
        "target_lon": "Target longitude value",
        "radius": "Radius within which to aggregate records"
      },
      "output_expected": "Aggregated counts of records grouped by the specified column for entries within the radius.",
      "explanation": "Groups spatially filtered records by a designated column and returns the count for each group.",
      "details": "Useful for analyzing spatial data categorization and distribution.",
      "function_call": "aggregate_query(parquet_file='{parquet_file}', group_column='{group_column}', lat_col='{lat_col}', lon_col='{lon_col}', target_lat={target_lat}, target_lon={target_lon}, radius={radius})",
      "imports_required": [
        "import duckdb",
        "from memories.utils.earth.geocode import compute_spatial_distance, create_point_geometry"
      ]
    },
    {
      "name": "Combined Filters Query",
      "function": "combined_filters_query",
      "code_to_execute": "SELECT * FROM '{parquet_file}' WHERE {text_column} LIKE '{pattern}' AND ST_Distance(ST_Point({lon_col}, {lat_col}), ST_Point({target_lon}, {target_lat})) < {radius};",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "text_column": "Name of the column for text pattern matching",
        "pattern": "Pattern to search for (e.g., '%pattern%')",
        "lat_col": "Name of the latitude column",
        "lon_col": "Name of the longitude column",
        "target_lat": "Target latitude value",
        "target_lon": "Target longitude value",
        "radius": "Radius within which to apply spatial filtering"
      },
      "output_expected": "Records meeting both the text-based and spatial proximity criteria.",
      "explanation": "Combines a LIKE-based text filter with a spatial filter based on proximity.",
      "details": "Useful when you want to apply both textual and geospatial filters on the dataset.",
      "function_call": "combined_filters_query(parquet_file='{parquet_file}', text_column='{text_column}', pattern='{pattern}', lat_col='{lat_col}', lon_col='{lon_col}', target_lat={target_lat}, target_lon={target_lon}, radius={radius})",
      "imports_required": [
        "import duckdb",
        "from memories.utils.earth.geocode import compute_spatial_distance, create_point_geometry"
      ]
    },
    {
      "name": "Range Query",
      "function": "range_query",
      "code_to_execute": "SELECT * FROM '{parquet_file}' WHERE {column_name} BETWEEN {min_value} AND {max_value};",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "column_name": "Name of the column to filter on",
        "min_value": "Minimum value of the range",
        "max_value": "Maximum value of the range"
      },
      "output_expected": "Records where the specified column's value falls within the given range.",
      "explanation": "Selects rows whose values in a specified column are within a given range.",
      "details": "Typically used for filtering numeric or date ranges.",
      "function_call": "range_query(parquet_file='{parquet_file}', column_name='{column_name}', min_value={min_value}, max_value={max_value})",
      "imports_required": ["import duckdb"]
    }
  ]
}
