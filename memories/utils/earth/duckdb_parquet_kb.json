{
  "queries": [
    {
      "name": "Exact Match Query",
      "function": "exact_match_query",
      "code_to_execute": "SELECT * FROM '{parquet_file}' WHERE {column_name} = '{value}';",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "column_name": "Name of the column to match against",
        "value": "The exact value to search"
      },
      "output_expected": "A dataset containing all rows where the column exactly matches the provided value.",
      "explanation": "This query filters the dataset by verifying each row's specified column against an exact value.",
      "details": "Use this query when you need to retrieve data based on an exact match; for example, filtering users by ID or name.",
      "function_call": "exact_match_query(parquet_file='{parquet_file}', column_name='{column_name}', value='{value}')",
      "imports_required": ["import duckdb"]
    },
    {
      "name": "LIKE Query",
      "function": "like_query",
      "code_to_execute": "SELECT * FROM '{parquet_file}' WHERE {column_name} LIKE '{pattern}';",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "column_name": "Column name to perform pattern matching",
        "pattern": "The pattern to search for, e.g., 'prefix%'"
      },
      "output_expected": "Rows where the column contains values matching the specified pattern.",
      "explanation": "Uses the SQL LIKE operator to facilitate pattern matching on text data.",
      "details": "Useful for fuzzy matching or searching for values that begin with, end with, or contain a certain substring.",
      "function_call": "like_query(parquet_file='{parquet_file}', column_name='{column_name}', pattern='{pattern}')",
      "imports_required": ["import duckdb"]
    },
    {
      "name": "At Coordinates Query",
      "function": "at_coordinates_query",
      "code_to_execute": "SELECT * FROM '{parquet_file}' WHERE {lat_col} = {target_lat} AND {lon_col} = {target_lon};",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "lat_col": "Name of the latitude column",
        "lon_col": "Name of the longitude column",
        "target_lat": "Target latitude value",
        "target_lon": "Target longitude value"
      },
      "output_expected": "Records that exactly match the given latitude and longitude.",
      "explanation": "This query retrieves data that is precisely at the specified coordinates.",
      "details": "Useful for pinpointing exact locations in geospatial datasets.",
      "function_call": "at_coordinates_query(parquet_file='{parquet_file}', lat_col='{lat_col}', lon_col='{lon_col}', target_lat={target_lat}, target_lon={target_lon})",
      "imports_required": ["import duckdb"]
    },
    {
      "name": "Within Radius Query",
      "function": "within_radius_query",
      "code_to_execute": "SELECT * FROM '{parquet_file}' WHERE ST_Distance(ST_Point({lon_col}, {lat_col}), ST_Point({target_lon}, {target_lat})) <= {radius};",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "lat_col": "Name of the latitude column",
        "lon_col": "Name of the longitude column",
        "target_lat": "Target latitude value",
        "target_lon": "Target longitude value",
        "radius": "Radius within which to search"
      },
      "output_expected": "Rows that are within the specified radius from the target coordinates.",
      "explanation": "Calculates the distance from each record to the target point and filters those within the given radius.",
      "details": "Assumes the presence of spatial functions like ST_Distance and ST_Point. Ideal for proximity search.",
      "function_call": "create_spatial_query(parquet_file='{parquet_file}', column_name='{column_name}', value='{value}', geometry_column='{geometry_column}', target_lat={target_lat}, target_lon={target_lon}, radius={radius})",
      "imports_required": [
        "from memories.utils.earth.geocode import create_spatial_query",
        "import duckdb"
      ]
    },
    {
      "name": "Nearest Query",
      "function": "nearest_query",
      "code_to_execute": "SELECT *, ST_Distance(ST_Point({lon_col}, {lat_col}), ST_Point({target_lon}, {target_lat})) AS distance FROM '{parquet_file}' ORDER BY distance ASC LIMIT 1;",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "lat_col": "Name of the latitude column",
        "lon_col": "Name of the longitude column",
        "target_lat": "Target latitude value",
        "target_lon": "Target longitude value"
      },
      "output_expected": "The row that is closest to the specified coordinates along with its calculated distance.",
      "explanation": "Sorts the rows by their distance from a target point and retrieves the nearest one.",
      "details": "Ideal for applications requiring nearest neighbor lookup in a spatial dataset.",
      "function_call": "nearest_query(parquet_file='{parquet_file}', lat_col='{lat_col}', lon_col='{lon_col}', target_lat={target_lat}, target_lon={target_lon})",
      "imports_required": [
        "import duckdb",
        "from memories.utils.earth.geocode import compute_spatial_distance, create_point_geometry"
      ]
    },
    {
      "name": "Bounding Box Query",
      "function": "bounding_box_query",
      "code_to_execute": "SELECT * FROM '{parquet_file}' WHERE {lat_col} BETWEEN {min_lat} AND {max_lat} AND {lon_col} BETWEEN {min_lon} AND {max_lon};",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "lat_col": "Name of the latitude column",
        "lon_col": "Name of the longitude column",
        "min_lat": "Minimum latitude value",
        "max_lat": "Maximum latitude value",
        "min_lon": "Minimum longitude value",
        "max_lon": "Maximum longitude value"
      },
      "output_expected": "All records that fall within the defined rectangular area.",
      "explanation": "Filters records whose latitude and longitude lie within the specified ranges.",
      "details": "Useful for spatial queries that define areas with bounding coordinates.",
      "function_call": "bounding_box_query(parquet_file='{parquet_file}', lat_col='{lat_col}', lon_col='{lon_col}', min_lat={min_lat}, max_lat={max_lat}, min_lon={min_lon}, max_lon={max_lon})",
      "imports_required": ["import duckdb"]
    },
    {
      "name": "Count Within Radius Query",
      "function": "count_within_radius_query",
      "code_to_execute": "SELECT COUNT(*) FROM '{parquet_file}' WHERE ST_Distance(ST_Point({lon_col}, {lat_col}), ST_Point({target_lon}, {target_lat})) < {radius};",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "lat_col": "Name of the latitude column",
        "lon_col": "Name of the longitude column",
        "target_lat": "Target latitude value",
        "target_lon": "Target longitude value",
        "radius": "Radius within which to count records"
      },
      "output_expected": "The number of records found within the specified radius.",
      "explanation": "Counts the number of locations within a given radius using spatial distance.",
      "details": "Ideal for obtaining summary statistics on spatial data.",
      "function_call": "count_within_radius_query(parquet_file='{parquet_file}', lat_col='{lat_col}', lon_col='{lon_col}', target_lat={target_lat}, target_lon={target_lon}, radius={radius})",
      "imports_required": [
        "import duckdb",
        "from memories.utils.earth.geocode import compute_spatial_distance, create_point_geometry"
      ]
    },
    {
      "name": "Aggregate Query",
      "function": "aggregate_query",
      "code_to_execute": "SELECT {group_column}, COUNT(*) FROM '{parquet_file}' WHERE ST_Distance(ST_Point({lon_col}, {lat_col}), ST_Point({target_lon}, {target_lat})) < {radius} GROUP BY {group_column};",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "group_column": "Column name to group the results by",
        "lat_col": "Name of the latitude column",
        "lon_col": "Name of the longitude column",
        "target_lat": "Target latitude value",
        "target_lon": "Target longitude value",
        "radius": "Radius within which to aggregate records"
      },
      "output_expected": "Aggregated counts of records grouped by the specified column for entries within the radius.",
      "explanation": "Groups spatially filtered records by a designated column and returns the count for each group.",
      "details": "Useful for analyzing spatial data categorization and distribution.",
      "function_call": "aggregate_query(parquet_file='{parquet_file}', group_column='{group_column}', lat_col='{lat_col}', lon_col='{lon_col}', target_lat={target_lat}, target_lon={target_lon}, radius={radius})",
      "imports_required": [
        "import duckdb",
        "from memories.utils.earth.geocode import compute_spatial_distance, create_point_geometry"
      ]
    },
    {
      "name": "Combined Filters Query",
      "function": "combined_filters_query",
      "code_to_execute": "SELECT * FROM '{parquet_file}' WHERE {text_column} LIKE '{pattern}' AND ST_Distance(ST_Point({lon_col}, {lat_col}), ST_Point({target_lon}, {target_lat})) < {radius};",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "text_column": "Name of the column for text pattern matching",
        "pattern": "Pattern to search for (e.g., '%pattern%')",
        "lat_col": "Name of the latitude column",
        "lon_col": "Name of the longitude column",
        "target_lat": "Target latitude value",
        "target_lon": "Target longitude value",
        "radius": "Radius within which to apply spatial filtering"
      },
      "output_expected": "Records meeting both the text-based and spatial proximity criteria.",
      "explanation": "Combines a LIKE-based text filter with a spatial filter based on proximity.",
      "details": "Useful when you want to apply both textual and geospatial filters on the dataset.",
      "function_call": "combined_filters_query(parquet_file='{parquet_file}', text_column='{text_column}', pattern='{pattern}', lat_col='{lat_col}', lon_col='{lon_col}', target_lat={target_lat}, target_lon={target_lon}, radius={radius})",
      "imports_required": [
        "import duckdb",
        "from memories.utils.earth.geocode import compute_spatial_distance, create_point_geometry"
      ]
    },
    {
      "name": "Range Query",
      "function": "range_query",
      "code_to_execute": "SELECT * FROM '{parquet_file}' WHERE {column_name} BETWEEN {min_value} AND {max_value};",
      "inputs_required": {
        "parquet_file": "Path to the Parquet file",
        "column_name": "Name of the column to filter on",
        "min_value": "Minimum value of the range",
        "max_value": "Maximum value of the range"
      },
      "output_expected": "Records where the specified column's value falls within the given range.",
      "explanation": "Selects rows whose values in a specified column are within a given range.",
      "details": "Typically used for filtering numeric or date ranges.",
      "function_call": "range_query(parquet_file='{parquet_file}', column_name='{column_name}', min_value={min_value}, max_value={max_value})",
      "imports_required": ["import duckdb"]
    }
  ]
}
