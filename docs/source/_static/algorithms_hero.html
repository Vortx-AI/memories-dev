<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
    }
    
    .svg-container {
      width: 100%;
      height: 100%;
      min-height: 300px;
    }
  </style>
</head>
<body>
  <div class="svg-container">
    <svg width="100%" height="100%" viewBox="0 0 800 400" xmlns="http://www.w3.org/2000/svg">
      <!-- Background -->
      <rect width="800" height="400" fill="#f8f9fa" class="bg" />
      
      <!-- Grid -->
      <g class="grid" stroke="#e0e0e0" stroke-width="1">
        <g id="vertical-lines"></g>
        <g id="horizontal-lines"></g>
      </g>
      
      <!-- Connection Network -->
      <g class="network" id="network"></g>
      
      <!-- Math Symbols -->
      <g class="math-symbols">
        <text x="100" y="100" font-size="24" fill="#4a86e8">∇f(x)</text>
        <text x="200" y="150" font-size="28" fill="#4a86e8">∫</text>
        <text x="300" y="80" font-size="22" fill="#4a86e8">∑</text>
        <text x="400" y="120" font-size="26" fill="#4a86e8">Ω</text>
        <text x="500" y="90" font-size="24" fill="#4a86e8">λ</text>
        <text x="600" y="130" font-size="22" fill="#4a86e8">∃</text>
        <text x="700" y="70" font-size="24" fill="#4a86e8">θ</text>
        <text x="650" y="200" font-size="28" fill="#4a86e8">∝</text>
        <text x="150" y="220" font-size="22" fill="#4a86e8">∈</text>
        <text x="250" y="280" font-size="24" fill="#4a86e8">∂</text>
        <text x="350" y="250" font-size="26" fill="#4a86e8">β</text>
        <text x="450" y="300" font-size="22" fill="#4a86e8">γ</text>
        <text x="550" y="330" font-size="24" fill="#4a86e8">δ</text>
        <text x="720" y="320" font-size="28" fill="#4a86e8">ε</text>
        <text x="520" y="210" font-size="22" fill="#4a86e8">μ</text>
        <text x="370" y="200" font-size="24" fill="#4a86e8">σ</text>
      </g>
      
      <!-- Algorithm Visualization -->
      <g class="algorithms" transform="translate(50, 50)">
        <!-- Kriging Visualization -->
        <g transform="translate(500, 220)" class="algorithm kriging">
          <circle cx="0" cy="0" r="20" fill="#4a86e8" opacity="0.7" />
          <circle cx="40" cy="-30" r="15" fill="#4a86e8" opacity="0.7" />
          <circle cx="-30" cy="40" r="25" fill="#4a86e8" opacity="0.7" />
          <circle cx="60" cy="20" r="18" fill="#4a86e8" opacity="0.7" />
          <circle cx="-50" cy="-20" r="15" fill="#4a86e8" opacity="0.7" />
          
          <!-- Interpolation surface -->
          <path d="M-60,-40 Q0,-80 60,-40 Q90,0 60,40 Q0,80 -60,40 Q-90,0 -60,-40Z" fill="#4a86e8" opacity="0.2" />
        </g>
        
        <!-- Point Pattern Visualization -->
        <g transform="translate(200, 150)" class="algorithm point-pattern">
          <circle cx="-30" cy="-20" r="5" fill="#e74c3c" />
          <circle cx="-20" cy="-30" r="5" fill="#e74c3c" />
          <circle cx="-15" cy="-25" r="5" fill="#e74c3c" />
          <circle cx="-25" cy="-15" r="5" fill="#e74c3c" />
          <circle cx="-10" cy="-20" r="5" fill="#e74c3c" />
          
          <circle cx="30" cy="25" r="5" fill="#e74c3c" />
          <circle cx="20" cy="30" r="5" fill="#e74c3c" />
          <circle cx="25" cy="20" r="5" fill="#e74c3c" />
          <circle cx="15" cy="25" r="5" fill="#e74c3c" />
          <circle cx="25" cy="15" r="5" fill="#e74c3c" />
          
          <circle cx="-30" cy="30" r="5" fill="#e74c3c" />
          <circle cx="30" cy="-30" r="5" fill="#e74c3c" />
          
          <!-- Circle showing clustering -->
          <circle cx="-20" cy="-22" r="20" fill="none" stroke="#e74c3c" stroke-width="2" stroke-dasharray="5,5" />
          <circle cx="23" cy="23" r="20" fill="none" stroke="#e74c3c" stroke-width="2" stroke-dasharray="5,5" />
        </g>
        
        <!-- Time Series Visualization -->
        <g transform="translate(300, 250)" class="algorithm time-series">
          <!-- Trend component -->
          <path d="M-100,0 L100,30" stroke="#2ecc71" stroke-width="3" fill="none" />
          
          <!-- Seasonal component -->
          <path d="M-100,0 Q-75,-20 -50,0 Q-25,20 0,0 Q25,-20 50,0 Q75,20 100,0" 
                stroke="#3498db" stroke-width="2" fill="none" />
          
          <!-- Combined series -->
          <path d="M-100,0 Q-85,-25 -75,-10 Q-65,5 -50,5 Q-35,15 -25,20 Q-15,25 0,30 Q15,35 25,20 Q35,5 50,30 Q65,55 75,40 Q85,25 100,30" 
                stroke="#8e44ad" stroke-width="3" fill="none" />
        </g>
      </g>
    </svg>
  </div>
  
  <script>
    // Create grid lines
    function createGrid() {
      const vLines = document.getElementById('vertical-lines');
      const hLines = document.getElementById('horizontal-lines');
      
      for (let i = 0; i <= 800; i += 40) {
        const vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        vLine.setAttribute('x1', i);
        vLine.setAttribute('y1', 0);
        vLine.setAttribute('x2', i);
        vLine.setAttribute('y2', 400);
        vLines.appendChild(vLine);
        
        const hLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        hLine.setAttribute('x1', 0);
        hLine.setAttribute('y1', i);
        hLine.setAttribute('x2', 800);
        hLine.setAttribute('y2', i);
        if (i <= 400) {
          hLines.appendChild(hLine);
        }
      }
    }
    
    // Create network connections
    function createNetwork() {
      const network = document.getElementById('network');
      const mathSymbols = document.querySelectorAll('.math-symbols text');
      const nodes = Array.from(mathSymbols).map(symbol => {
        return {
          x: parseFloat(symbol.getAttribute('x')),
          y: parseFloat(symbol.getAttribute('y'))
        };
      });
      
      // Connect some nodes randomly
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          if (Math.random() < 0.2) { // 20% chance to create a connection
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', nodes[i].x);
            line.setAttribute('y1', nodes[i].y);
            line.setAttribute('x2', nodes[j].x);
            line.setAttribute('y2', nodes[j].y);
            line.setAttribute('stroke', '#4a86e8');
            line.setAttribute('stroke-width', '1');
            line.setAttribute('opacity', '0.3');
            network.appendChild(line);
          }
        }
      }
    }
    
    // Add support for dark mode
    function setupDarkMode() {
      const svg = document.querySelector('svg');
      const bg = document.querySelector('.bg');
      const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      
      if (isDarkMode) {
        bg.setAttribute('fill', '#1a1a1a');
        
        // Change grid color
        document.querySelectorAll('.grid line').forEach(line => {
          line.setAttribute('stroke', '#333');
        });
        
        // Change text color
        document.querySelectorAll('.math-symbols text').forEach(text => {
          text.setAttribute('fill', '#5f97f6');
        });
        
        // Change algorithm colors
        document.querySelectorAll('.algorithm circle').forEach(circle => {
          if (circle.getAttribute('fill') === '#4a86e8') {
            circle.setAttribute('fill', '#5f97f6');
          } else if (circle.getAttribute('fill') === '#e74c3c') {
            circle.setAttribute('fill', '#ff6b6b');
          }
        });
        
        document.querySelectorAll('.algorithm path').forEach(path => {
          if (path.getAttribute('fill') === '#4a86e8') {
            path.setAttribute('fill', '#5f97f6');
          } else if (path.getAttribute('stroke') === '#4a86e8') {
            path.setAttribute('stroke', '#5f97f6');
          } else if (path.getAttribute('stroke') === '#e74c3c') {
            path.setAttribute('stroke', '#ff6b6b');
          } else if (path.getAttribute('stroke') === '#2ecc71') {
            path.setAttribute('stroke', '#2fb344');
          } else if (path.getAttribute('stroke') === '#3498db') {
            path.setAttribute('stroke', '#2392a9');
          } else if (path.getAttribute('stroke') === '#8e44ad') {
            path.setAttribute('stroke', '#9b59b6');
          }
        });
        
        // Change network lines
        document.querySelectorAll('.network line').forEach(line => {
          line.setAttribute('stroke', '#5f97f6');
        });
      }
    }
    
    // Initialize the visualization
    window.addEventListener('DOMContentLoaded', () => {
      createGrid();
      createNetwork();
      setupDarkMode();
      
      // Listen for dark mode changes
      if (window.matchMedia) {
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', setupDarkMode);
      }
    });
  </script>
</body>
</html> 